"""
Book handlers
"""

from .schema_handler import load_schema

#: The Type Mapping maps the type strings in the schema to the types as loaded.
TYPE_MAPPING = {}

class BaseObject(object):
    """
    This is a base class for objects as generated by the schema.
    """
    PROPERTIES = tuple()
    
    def __init__(self, **kwargs):
        base_kwargs = {k: None for k in self.PROPERTIES}

        extra_kwargs = set(kwargs.keys()) - set(base_kwargs)

        if len(extra_kwargs):
            raise TypeError('__init__ got unexpected keywords:' + 
                            ','.join("'{}'".format(k) for k in extra_kwargs) +
                            '.')

        base_kwargs.update(kwargs)

        for k, v in base_kwargs.items():
            setattr(self, k, v)

    def to_dict(self):
        return {k: getattr(self, k) for k in self.PROPERTIES}

    def to_dict_sparse(self):
        return {k: v for k, v in self.to_dict().items() if v is not None}


def object_factory(name, properties, bases=(BaseObject, ), clsdict=None):
    """
    A function for generating classes from the schema-specified types.
    """
    PROPERTIES = tuple(properties)
    if clsdict is None:
        clsdict = {}
    else:
        clsdict = clsdict.copy()

    clsdict.update({'PROPERTIES': PROPERTIES})

    return type(name, bases, clsdict)


def load_classes(schema=None):
    args = (schema,) if schema else tuple()
    schema = load_schema(*args)

    type_dict = {}

    for ctype_name, ctype_def in schema['types'].items():
        # The properties are defined in 'fields'
        clsdict = {}
        if 'docstring' in ctype_def:
            clsdict['__doc__'] = ctype_def['docstring']

        ctype_props = ctype_def['fields']

        ctype = object_factory(ctype_name, ctype_props, clsdict=clsdict)

        type_dict[ctype_name] = ctype

    globals().update(type_dict)

    global TYPE_MAPPING
    TYPE_MAPPING = {}
    TYPE_MAPPING.update(type_dict)

# Use the base schema to generate the classes.
load_classes()

